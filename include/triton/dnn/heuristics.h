#ifndef TRITON_DNN_HEURISTICS_H
#define TRITON_DNN_HEURISTICS_H

#include <vector>
#include "triton/dnn/base.h"

namespace triton{
namespace dnn{

/* Dense matrix multiplication */

typedef std::vector<unsigned> params_t;
typedef std::tuple<bool, bool> trans_key_t;
typedef std::tuple<size_t, size_t> size_key_t;
static const std::map<trans_key_t, std::map<size_key_t, params_t>> dot_params = {
  /* NN */
  {trans_key_t(false, false), std::map<size_key_t, params_t>{
      {size_key_t(16, 16),   {2, 8, 16, 4, 16, 2, 2, 1, 1, 16, 32, 8, 4, 1}},
      {size_key_t(16, 32),   {4, 4, 16, 4, 32, 2, 2, 1, 1, 8, 32, 8, 4, 1}},
      {size_key_t(16, 64),   {4, 4, 16, 4, 64, 2, 2, 1, 1, 8, 32, 8, 4, 1}},
      {size_key_t(16, 128),  {2, 8, 16, 8, 128, 2, 2, 1, 1, 16, 32, 4, 8, 1}},
      {size_key_t(32, 16),   {8, 4, 32, 8, 16, 2, 2, 1, 1, 4, 32, 4, 8, 1}},
      {size_key_t(32, 32),   {4, 8, 32, 4, 32, 2, 2, 1, 1, 8, 32, 8, 4, 1}},
      {size_key_t(32, 64),   {8, 4, 32, 4, 64, 2, 2, 1, 1, 4, 32, 8, 4, 1}},
      {size_key_t(32, 128),  {8, 4, 32, 32, 128, 2, 2, 2, 2, 16, 32, 4, 4, 1}},
      {size_key_t(32, 256),  {4, 8, 32, 32, 256, 2, 2, 1, 4, 32, 32, 4, 8, 1}},
      {size_key_t(64, 16),   {8, 8, 64, 8, 16, 2, 2, 1, 1, 4, 32, 4, 8, 1}},
      {size_key_t(64, 32),   {8, 8, 64, 8, 32, 2, 2, 1, 1, 4, 32, 4, 8, 1}},
      {size_key_t(64, 64),   {8, 8, 64, 16, 64, 2, 2, 1, 2, 8, 32, 4, 8, 1}},
      {size_key_t(64, 128),  {16, 4, 64, 32, 128, 2, 2, 1, 4, 8, 32, 4, 8, 1}},
      {size_key_t(128, 16),  {8, 8, 128, 16, 16, 2, 2, 2, 1, 8, 32, 4, 8, 1}},
      {size_key_t(128, 32),  {32, 4, 128, 16, 32, 2, 2, 2, 1, 2, 32, 4, 8, 1}},
      {size_key_t(128, 64),  {16, 8, 128, 16, 64, 2, 2, 2, 2, 8, 32, 8, 4, 1}},
      {size_key_t(128, 128), {8, 8, 128, 32, 128, 2, 2, 2, 2, 16, 32, 4, 8, 1}},
      {size_key_t(256, 16),  {32, 8, 256, 16, 16, 2, 2, 4, 1, 4, 32, 8, 4, 1}},
      {size_key_t(256, 32),  {32, 8, 256, 16, 32, 2, 2, 4, 1, 4, 32, 8, 4, 1}},
      {size_key_t(256, 64),  {16, 8, 256, 32, 64, 2, 2, 4, 1, 8, 32, 4, 8, 1}}
   }},
  /* NT */
  {trans_key_t(false, true), std::map<size_key_t, params_t>{
     {size_key_t(16, 16),   {2, 4, 16, 2, 8, 16, 2, 2, 1, 1, 16, 32, 16, 1}},
     {size_key_t(16, 32),   {4, 4, 16, 8, 4, 32, 2, 2, 1, 1, 8, 32, 4, 1}},
     {size_key_t(16, 64),   {2, 4, 16, 2, 8, 64, 2, 2, 1, 1, 16, 32, 16, 1}},
     {size_key_t(16, 128),  {2, 8, 16, 8, 8, 128, 2, 2, 1, 1, 16, 32, 4, 1}},
     {size_key_t(32, 16),   {8, 4, 32, 2, 8, 16, 2, 2, 1, 1, 4, 32, 16, 1}},
     {size_key_t(32, 32),   {4, 8, 32, 8, 4, 32, 2, 2, 1, 1, 8, 32, 4, 1}},
     {size_key_t(32, 64),   {16, 4, 64, 16, 4, 64, 2, 2, 4, 1, 8, 32, 8, 1}},
     {size_key_t(32, 128),  {4, 8, 32, 16, 4, 128, 2, 2, 1, 2, 16, 32, 4, 1}},
     {size_key_t(32, 256),  {4, 8, 32, 64, 4, 256, 2, 2, 1, 4, 32, 32, 2, 1}},
     {size_key_t(64, 16),   {8, 8, 64, 2, 8, 16, 2, 2, 1, 1, 4, 32, 16, 1}},
     {size_key_t(64, 32),   {16, 4, 64, 4, 4, 32, 2, 2, 1, 1, 2, 32, 8, 1}},
     {size_key_t(64, 64),   {8, 8, 64, 8, 8, 64, 2, 2, 2, 1, 8, 32, 8, 1}},
     {size_key_t(64, 128),  {4, 4, 64, 8, 8, 128, 2, 2, 1, 4, 32, 32, 16, 1}},
     {size_key_t(64, 256),  {8, 8, 64, 8, 8, 256, 2, 2, 1, 4, 16, 32, 16, 1}},
     {size_key_t(128, 16),  {16, 8, 128, 2, 8, 16, 2, 2, 1, 1, 2, 32, 16, 1}},
     {size_key_t(128, 32),  {32, 4, 128, 4, 8, 32, 2, 2, 2, 1, 2, 32, 16, 1}},
     {size_key_t(128, 64),  {8, 8, 128, 8, 8, 64, 2, 2, 4, 1, 16, 32, 16, 1}},
     {size_key_t(128, 128), {8, 8, 128, 16, 8, 128, 2, 2, 2, 2, 16, 32, 8, 1}},
     {size_key_t(256, 16),  {32, 4, 256, 4, 4, 16, 2, 2, 4, 1, 4, 32, 32, 1}},
     {size_key_t(256, 32),  {16, 8, 256, 8, 4, 32, 2, 2, 4, 1, 8, 32, 16, 1}},
     {size_key_t(256, 64),  {8, 8, 256, 8, 8, 64, 2, 2, 4, 1, 16, 32, 16, 1}}
  }},
  /* TN */
  {trans_key_t(true, false), std::map<size_key_t, params_t>{
     {size_key_t(16, 16),   {4, 16, 4, 16, 2, 2, 1, 1, 8, 4, 32, 8, 4, 1}},
     {size_key_t(16, 32),   {8, 16, 8, 32, 2, 2, 1, 1, 4, 4, 32, 4, 4, 1}},
     {size_key_t(16, 64),   {4, 16, 8, 64, 2, 2, 1, 1, 8, 4, 32, 4, 8, 1}},
     {size_key_t(16, 128),  {4, 16, 8, 128, 2, 2, 1, 1, 8, 4, 32, 4, 8, 1}},
     {size_key_t(32, 16),   {4, 32, 8, 16, 2, 2, 1, 1, 8, 4, 32, 4, 8, 1}},
     {size_key_t(32, 32),   {4, 32, 4, 32, 2, 2, 1, 1, 8, 4, 32, 8, 4, 1}},
     {size_key_t(32, 64),   {4, 32, 4, 64, 2, 2, 1, 1, 8, 4, 32, 8, 4, 1}},
     {size_key_t(32, 128),  {8, 32, 8, 128, 2, 2, 1, 1, 4, 8, 32, 4, 8, 1}},
     {size_key_t(32, 256),  {32, 32, 32, 256, 2, 2, 1, 4, 4, 8, 32, 4, 8, 1}},
     {size_key_t(64, 16),   {4, 64, 8, 16, 2, 2, 1, 1, 8, 4, 32, 4, 8, 1}},
     {size_key_t(64, 32),   {4, 64, 4, 32, 2, 2, 1, 1, 8, 4, 32, 8, 4, 1}},
     {size_key_t(64, 64),   {8, 64, 16, 64, 2, 2, 2, 1, 8, 4, 32, 4, 8, 1}},
     {size_key_t(64, 128),  {16, 64, 32, 128, 2, 2, 1, 4, 8, 4, 32, 4, 8, 1}},
     {size_key_t(128, 16),  {8, 128, 8, 16, 2, 2, 1, 1, 4, 8, 32, 4, 8, 1}},
     {size_key_t(128, 32),  {16, 128, 16, 32, 2, 2, 4, 1, 8, 4, 32, 8, 4, 1}},
     {size_key_t(128, 64),  {32, 128, 32, 64, 2, 2, 2, 2, 4, 8, 32, 4, 8, 1}},
     {size_key_t(128, 128), {32, 128, 32, 128, 2, 2, 1, 4, 4, 8, 32, 4, 8, 1}},
     {size_key_t(256, 16),  {16, 256, 16, 16, 2, 2, 2, 1, 4, 8, 32, 4, 8, 1}},
     {size_key_t(256, 32),  {16, 256, 32, 32, 2, 2, 4, 1, 8, 4, 32, 4, 8, 1}},
  }},
  /* TT */
  {trans_key_t(true, true), std::map<size_key_t, params_t>{
     {size_key_t(16, 16),   {8, 16, 4, 4, 16, 2, 2, 1, 1, 4, 8, 32, 8, 1}},
     {size_key_t(16, 32),   {8, 16, 8, 4, 32, 2, 2, 1, 1, 4, 8, 32, 4, 1}},
     {size_key_t(16, 64),   {16, 16, 4, 8, 64, 2, 2, 1, 4, 8, 4, 32, 32, 1}},
     {size_key_t(16, 128),  {16, 16, 8, 8, 128, 2, 2, 1, 1, 2, 4, 32, 4, 1}},
     {size_key_t(32, 16),   {4, 32, 4, 4, 16, 2, 2, 1, 1, 8, 4, 32, 8, 1}},
     {size_key_t(32, 32),   {8, 32, 8, 4, 32, 2, 2, 1, 1, 4, 8, 32, 4, 1}},
     {size_key_t(32, 64),   {64, 128, 8, 4, 64, 2, 2, 4, 1, 2, 8, 32, 16, 1}},
     {size_key_t(32, 128),  {16, 32, 32, 4, 128, 2, 2, 1, 2, 4, 8, 32, 2, 1}},
     {size_key_t(32, 256),  {32, 32, 32, 4, 256, 2, 2, 1, 4, 4, 8, 32, 4, 1}},
     {size_key_t(64, 16),   {4, 64, 2, 8, 16, 2, 2, 1, 1, 8, 4, 32, 16, 1}},
     {size_key_t(64, 32),   {4, 64, 8, 4, 32, 2, 2, 1, 1, 8, 4, 32, 4, 1}},
     {size_key_t(64, 64),   {16, 64, 8, 8, 64, 2, 2, 2, 1, 4, 8, 32, 8, 1}},
     {size_key_t(64, 128),  {32, 64, 8, 8, 128, 2, 2, 1, 4, 4, 4, 32, 16, 1}},
     {size_key_t(64, 256),  {64, 64, 8, 8, 256, 2, 2, 1, 4, 2, 8, 32, 16}},
     {size_key_t(128, 16),  {8, 128, 2, 8, 16, 2, 2, 1, 1, 4, 8, 32, 16, 1}},
     {size_key_t(128, 32),  {16, 128, 8, 4, 32, 2, 2, 4, 1, 8, 4, 32, 16, 1}},
     {size_key_t(128, 64),  {32, 128, 8, 8, 64, 2, 2, 4, 1, 4, 8, 32, 16, 1}},
     {size_key_t(128, 128), {32, 128, 16, 8, 128, 2, 2, 2, 2, 4, 8, 32, 8, 1}},
     {size_key_t(256, 16),  {32, 256, 4, 4, 16, 2, 2, 4, 1, 4, 8, 32, 32, 1}},
     {size_key_t(256, 32),  {32, 256, 8, 4, 32, 2, 2, 4, 1, 4, 8, 32, 16, 1}}
  }}
};

// small search space for partial auto-tuning
inline std::vector<params_t> dot_search_space(bool AT, bool BT) {
  std::vector<params_t> result;
  for(auto x: dot_params.at(trans_key_t{AT, BT}))
    result.push_back(x.second);
  return result;
}

// simple parameter heuristics
inline params_t dot_heuristics(bool AT, bool BT, size_t M, size_t N, size_t K) {
  size_t TM = 128;
  size_t TN = 128;
//  return {4, 4, 128, 8, 4, 128, 2, 2, 2, 2, 32, 32, 16, 1};
  return dot_params.at(trans_key_t{AT, BT}).at(size_key_t{TM, TN});
}


/* Block-sparse matrix multiplication */

static const std::map<std::pair<bool, size_t>, std::map<size_t, params_t>> bsdot_params = {
  /* 32x32 */
  {{true, 32}, std::map<size_t, params_t>{
      {32, {2, 2, 32, 32, 2, 2, 4, 8, 32, 32, 8, 4, 16}},
      {64, {2, 2, 64, 32, 2, 1, 16, 4, 4, 32, 16, 2, 4}},
      {128, {2, 2, 128, 32, 4, 1, 32, 4, 4, 32, 8, 4, 16}}
  }},
  {{false, 32}, std::map<size_t, params_t>{
      {32, {2, 2, 32, 32, 1, 1, 8, 4, 4, 32, 8, 4, 8}},
      {64, {2, 2, 64, 32, 2, 1, 16, 4, 4, 32, 16, 4, 8}},
      {128, {2, 2, 128, 32, 4, 1, 32, 4, 4, 32, 32, 4, 8}}
   }}
};

// small search space for partial auto-tuning
inline std::vector<params_t> bsdot_search_space(bool is_fprop, size_t block_size) {
  std::vector<params_t> result;
  for(auto x: bsdot_params.at({is_fprop, block_size}))
    result.push_back(x.second);
  return result;
}

// simple parameter heuristics
inline params_t bsdot_heuristics(bool is_fprop, size_t block_size, size_t N, size_t S) {
  return bsdot_params.at({is_fprop,block_size}).at(128);
}


}
}

#endif
