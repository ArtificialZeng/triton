# TritonOps<!-- Autogenerated by mlir-tblgen; don't manually edit -->
### `tt.call` (::mlir::triton::CallOp)

call operation


Syntax:

```
operation ::= `tt.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
```

The `tt.call` operation represents a direct call to a function that is
within the same symbol scope as the call. The operands and result types of
the call must match the specified function type. The callee is encoded as a
symbol reference attribute named "callee".

Example:

```mlir
%2 = tt.call @my_add(%0, %1) : (f32, f32) -> f32
```

Traits: TensorSizeTrait

Interfaces: CallOpInterface, SymbolUserOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `callee` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
&laquo;unnamed&raquo; | any type

### `tt.func` (::mlir::triton::FuncOp)

An operation with a name containing a single `SSACFG` region

Operations within the function cannot implicitly capture values defined
outside of the function, i.e. Functions are `IsolatedFromAbove`. All
external references must use function arguments or attributes that establish
a symbolic connection (e.g. symbols referenced by name via a string
attribute like SymbolRefAttr). An external function declaration (used when
referring to a function declared in some other module) has no body. While
the MLIR textual form provides a nice inline syntax for function arguments,
they are internally represented as “block arguments” to the first block in
the region.

Only dialect attribute names may be specified in the attribute dictionaries
for function arguments, results, or the function itself.

Example:

```mlir
// External function definitions.
tt.func @abort()
tt.func @scribble(i32, i64, memref<? x 128 x f32, #layout_map0>) -> f64

// A function that returns its argument twice:
tt.func @count(%x: i64) -> (i64, i64)
  attributes {fruit: "banana"} {
  return %x, %x: i64, i64
}

// A function with an argument attribute
tt.func @example_fn_arg(%x: i32 {swift.self = unit})

// A function with a result attribute
tt.func @example_fn_result() -> (f64 {dialectName.attrName = 0 : i64})

// A function with an attribute
tt.func @example_fn_attr() attributes {dialectName.attrName = false}
```

Traits: AffineScope, AutomaticAllocationScope, IsolatedFromAbove, TensorSizeTrait

Interfaces: CallableOpInterface, FunctionOpInterface, OpAsmOpInterface, Symbol

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sym_name` | ::mlir::StringAttr | string attribute
| `function_type` | ::mlir::TypeAttr | type attribute of function type
| `sym_visibility` | ::mlir::StringAttr | string attribute
| `arg_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes
| `res_attrs` | ::mlir::ArrayAttr | Array of dictionary attributes

### `tt.return` (::mlir::triton::ReturnOp)

Function return operation


Syntax:

```
operation ::= `tt.return` attr-dict ($operands^ `:` type($operands))?
```

The `tt.return` operation represents a return operation within a function.
The operation takes variable number of operands and produces no results.
The operand number and types must match the signature of the function
that contains the operation.

Example:

```mlir
tt.func @foo() : (i32, f8) {
  ...
  tt.return %0, %1 : i32, f8
}
```

Traits: AlwaysSpeculatableImplTrait, HasParent<FuncOp>, ReturnLike, TensorSizeTrait, Terminator

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | any type

### `tt.addptr` (::mlir::triton::AddPtrOp)




Syntax:

```
operation ::= `tt.addptr` $ptr `,` $offset attr-dict `:` type($result) `,` type($offset)
```


Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `ptr` | ptr or tensor of ptr values
| `offset` | integer or tensor of integer values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | ptr or tensor of ptr values

### `tt.advance` (::mlir::triton::AdvanceOp)

Advance a tensor pointer by offsets


Syntax:

```
operation ::= `tt.advance` $ptr `,` `[` $offsets `]` attr-dict `:` type($result)
```


Traits: AlwaysSpeculatableImplTrait, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `ptr` | ptr
| `offsets` | 32-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | ptr

### `tt.assert` (::mlir::triton::AssertOp)

Device-side assert, as in CUDA for correctness checking


Syntax:

```
operation ::= `tt.assert` $condition `,` $message `,` $file `,` $func `,` $line attr-dict `:` type($condition)
```

`tt.assert` takes a condition tensor, a message string, a file string, a function string, and a line number.
If the condition is false, the message is printed, and the program is aborted.

Traits: TensorSizeTrait

Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `message` | ::mlir::StringAttr | string attribute
| `file` | ::mlir::StringAttr | string attribute
| `func` | ::mlir::StringAttr | string attribute
| `line` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `condition` | tensor of floating-point values or tensor of integer values or tensor of ptr values

### `tt.atomic_cas` (::mlir::triton::AtomicCASOp)

atomic cas

compare $cmp with data $old at location $ptr,

if $old == $cmp, store $val to $ptr,

else store $old to $ptr,

return $old

Traits: SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `sem` | ::mlir::triton::MemSemanticAttr | allowed 32-bit signless integer cases: 1, 2, 3, 4

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `ptr` | ptr or tensor of ptr values
| `cmp` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr
| `val` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.atomic_rmw` (::mlir::triton::AtomicRMWOp)

atomic rmw

load data at $ptr, do $rmw_op with $val, and store result to $ptr.

return old value at $ptr

Traits: SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `atomic_rmw_op` | ::mlir::triton::RMWOpAttr | allowed 32-bit signless integer cases: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
| `sem` | ::mlir::triton::MemSemanticAttr | allowed 32-bit signless integer cases: 1, 2, 3, 4

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `ptr` | ptr or tensor of ptr values
| `val` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr
| `mask` | 1-bit signless integer or tensor of 1-bit signless integer values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.bitcast` (::mlir::triton::BitcastOp)

Cast between types of the same bitwidth


Syntax:

```
operation ::= `tt.bitcast` $from attr-dict `:` type($from) `->` type($result)
```


Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `from` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.broadcast` (::mlir::triton::BroadcastOp)

broadcast. No left-padding as of now.


Syntax:

```
operation ::= `tt.broadcast` $src attr-dict `:` functional-type(operands, results)
```


Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultElementType, SameOperandsAndResultEncoding, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.cat` (::mlir::triton::CatOp)

concatenate 2 tensors


Syntax:

```
operation ::= `tt.cat` $lhs `,` $rhs attr-dict `:` functional-type(operands, results)
```


Traits: SameOperandsAndResultElementType, TensorSizeTrait

Interfaces: NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `lhs` | tensor of floating-point values or tensor of integer values or tensor of ptr values
| `rhs` | tensor of floating-point values or tensor of integer values or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of floating-point values or tensor of integer values or tensor of ptr values

### `tt.dot` (::mlir::triton::DotOp)

dot


Syntax:

```
operation ::= `tt.dot` $a`,` $b`,` $c attr-dict `:` type($a) `*` type($b) `->` type($d)
```

$d = matrix_multiply($a, $b) + $c

Traits: AlwaysSpeculatableImplTrait, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `allowTF32` | ::mlir::BoolAttr | bool attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `a` | tensor of floating-point values or tensor of integer values
| `b` | tensor of floating-point values or tensor of integer values
| `c` | tensor of floating-point values or tensor of integer values

#### Results:

| Result | Description |
| :----: | ----------- |
| `d` | tensor of floating-point values or tensor of integer values

### `tt.elementwise_inline_asm` (::mlir::triton::ElementwiseInlineAsmOp)

inline assembly applying elementwise operation to a group of packed element.


Syntax:

```
operation ::= `tt.elementwise_inline_asm` $asm_string attr-dict ($args^ `:` type($args))? `->` type($result)
```

This will apply the given in inline assembly to `packed_element` number of
elements of the inputs. The elements packed together is unknown and will
depend on the backend implementation.

Traits: Elementwise, SameOperandsAndResultEncoding, TensorSizeTrait

Interfaces: MemoryEffectOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `asm_string` | ::mlir::StringAttr | string attribute
| `constraints` | ::mlir::StringAttr | string attribute
| `pure` | ::mlir::BoolAttr | bool attribute
| `packed_element` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.expand_dims` (::mlir::triton::ExpandDimsOp)

expand_dims


Syntax:

```
operation ::= `tt.expand_dims` $src attr-dict `:` functional-type(operands, results)
```


Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultElementType, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `axis` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | tensor of floating-point values or tensor of integer values or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of floating-point values or tensor of integer values or tensor of ptr values

### `tt.extern_elementwise` (::mlir::triton::ExternElementwiseOp)




Syntax:

```
operation ::= `tt.extern_elementwise` operands attr-dict `:` functional-type(operands, $result)
```

call an external function $symbol implemented in $libpath/$libname with $args
return $libpath/$libname:$symbol($args...)

Traits: Elementwise, SameOperandsAndResultEncoding, SameVariadicOperandSize, TensorSizeTrait

Interfaces: MemoryEffectOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `libname` | ::mlir::StringAttr | string attribute
| `libpath` | ::mlir::StringAttr | string attribute
| `symbol` | ::mlir::StringAttr | string attribute
| `pure` | ::mlir::BoolAttr | bool attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.fp_to_fp` (::mlir::triton::FpToFpOp)

Floating point casting for custom types


Syntax:

```
operation ::= `tt.fp_to_fp` $from attr-dict `:` type($from) `->` type($result)
```

Floating point casting for custom types (F8).

F8 <-> FP16, BF16, FP32, FP64

Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `from` | floating-point or tensor of floating-point values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values

### `tt.get_num_programs` (::mlir::triton::GetNumProgramsOp)




Syntax:

```
operation ::= `tt.get_num_programs` attr-dict `:` type($result)
```


Traits: AlwaysSpeculatableImplTrait, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `axis` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 32-bit signless integer

### `tt.get_program_id` (::mlir::triton::GetProgramIdOp)




Syntax:

```
operation ::= `tt.get_program_id` $axis attr-dict `:` type($result)
```


Traits: AlwaysSpeculatableImplTrait, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `axis` | ::mlir::triton::ProgramIDDimAttr | allowed 32-bit signless integer cases: 0, 1, 2

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 32-bit signless integer

### `tt.int_to_ptr` (::mlir::triton::IntToPtrOp)

Cast int64 to pointer


Syntax:

```
operation ::= `tt.int_to_ptr` $from attr-dict `:` type($from) `->` type($result)
```


Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `from` | 64-bit signless integer or tensor of 64-bit signless integer values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | ptr or tensor of ptr values

### `tt.load` (::mlir::triton::LoadOp)

Load from a tensor of pointers or from a tensor pointer


Traits: AttrSizedOperandSegments, SameLoadStoreOperandsAndResultEncoding, SameLoadStoreOperandsAndResultShape, TensorSizeTrait

Interfaces: MemoryEffectOpInterface

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `boundaryCheck` | ::mlir::DenseI32ArrayAttr | i32 dense array attribute
| `padding` | ::mlir::triton::PaddingOptionAttr | allowed 32-bit signless integer cases: 1, 2
| `cache` | ::mlir::triton::CacheModifierAttr | allowed 32-bit signless integer cases: 1, 2, 3, 4, 5, 6
| `evict` | ::mlir::triton::EvictionPolicyAttr | allowed 32-bit signless integer cases: 1, 2, 3
| `isVolatile` | ::mlir::BoolAttr | bool attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `ptr` | ptr or tensor of ptr values or ptr
| `mask` | 1-bit signless integer or tensor of 1-bit signless integer values
| `other` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.make_range` (::mlir::triton::MakeRangeOp)

make range


Syntax:

```
operation ::= `tt.make_range` attr-dict `:` type($result)
```

Returns an 1D int32 tensor.

Values span from $start to $end (exclusive), with step = 1

Traits: AlwaysSpeculatableImplTrait, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `start` | ::mlir::IntegerAttr | 32-bit signless integer attribute
| `end` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of integer values

### `tt.make_tensor_ptr` (::mlir::triton::MakeTensorPtrOp)

Make a tensor pointer type with meta information of the parent tensor and the block specified


Syntax:

```
operation ::= `tt.make_tensor_ptr` $base `,` `[` $shape `]` `,` `[` $strides `]` `,` `[` $offsets `]` attr-dict `:` type($result)
```

`tt.make_tensor_ptr` takes both meta information of the parent tensor and the block tensor, then it returns a
pointer to the block tensor, e.g. returns a type of `tt.ptr<tensor<8x8xf16>>`.

Traits: AlwaysSpeculatableImplTrait, SameVariadicOperandSize, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `order` | ::mlir::DenseI32ArrayAttr | i32 dense array attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `base` | ptr
| `shape` | 64-bit signless integer
| `strides` | 64-bit signless integer
| `offsets` | 32-bit signless integer

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | ptr

### `tt.print` (::mlir::triton::PrintOp)

Device-side print, as in CUDA for debugging


Syntax:

```
operation ::= `tt.print` $prefix attr-dict (`:` $args^ `:` type($args))?
```

`tt.print` takes a literal string prefix and an arbitrary number of scalar or tensor arguments that should be printed.
format are generated automatically from the arguments.

Traits: TensorSizeTrait

Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `prefix` | ::mlir::StringAttr | string attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `args` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.ptr_to_int` (::mlir::triton::PtrToIntOp)

Cast pointer to int64


Syntax:

```
operation ::= `tt.ptr_to_int` $from attr-dict `:` type($from) `->` type($result)
```


Traits: AlwaysSpeculatableImplTrait, Elementwise, SameOperandsAndResultEncoding, SameOperandsAndResultShape, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `from` | ptr or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | 64-bit signless integer or tensor of 64-bit signless integer values

### `tt.reduce` (::mlir::triton::ReduceOp)

Reduction using generic combination algorithm


Traits: AlwaysSpeculatableImplTrait, SameOperandsEncoding, SingleBlock, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `axis` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | tensor of floating-point values or tensor of integer values or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

### `tt.reduce.return` (::mlir::triton::ReduceReturnOp)

terminator for reduce operator


Syntax:

```
operation ::= `tt.reduce.return` $result attr-dict `:` type($result)
```


Traits: AlwaysSpeculatableImplTrait, HasParent<ReduceOp>, ReturnLike, TensorSizeTrait, Terminator

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `tt.scan` (::mlir::triton::ScanOp)

Reduction using generic combination algorithm


Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultElementType, SameOperandsAndResultEncoding, SingleBlock, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `axis` | ::mlir::IntegerAttr | 32-bit signless integer attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `operands` | tensor of floating-point values or tensor of integer values or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of floating-point values or tensor of integer values or tensor of ptr values

### `tt.scan.return` (::mlir::triton::ScanReturnOp)

terminator for scan operator


Syntax:

```
operation ::= `tt.scan.return` $result attr-dict `:` type($result)
```


Traits: AlwaysSpeculatableImplTrait, HasParent<ScanOp>, ReturnLike, TensorSizeTrait, Terminator

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `result` | any type

### `tt.splat` (::mlir::triton::SplatOp)

splat


Syntax:

```
operation ::= `tt.splat` $src attr-dict `:` functional-type(operands, results)
```


Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultElementType, SameOperandsAndResultEncoding, TensorSizeTrait

Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of floating-point values or tensor of integer values or tensor of ptr values

### `tt.store` (::mlir::triton::StoreOp)

Store by a tensor of pointers or by a tensor pointer


Traits: SameLoadStoreOperandsEncoding, SameLoadStoreOperandsShape, TensorSizeTrait

Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `boundaryCheck` | ::mlir::DenseI32ArrayAttr | i32 dense array attribute
| `cache` | ::mlir::triton::CacheModifierAttr | allowed 32-bit signless integer cases: 1, 2, 3, 4, 5, 6
| `evict` | ::mlir::triton::EvictionPolicyAttr | allowed 32-bit signless integer cases: 1, 2, 3

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `ptr` | ptr or tensor of ptr values or ptr
| `value` | floating-point or tensor of floating-point values or integer or tensor of integer values or ptr or tensor of ptr values or ptr
| `mask` | 1-bit signless integer or tensor of 1-bit signless integer values

### `tt.trans` (::mlir::triton::TransOp)

transpose a tensor


Syntax:

```
operation ::= `tt.trans` $src attr-dict `:` functional-type(operands, results)
```


Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultElementType, TensorSizeTrait

Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | tensor of floating-point values or tensor of integer values or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of floating-point values or tensor of integer values or tensor of ptr values

### `tt.view` (::mlir::triton::ViewOp)

view


Syntax:

```
operation ::= `tt.view` $src attr-dict `:` functional-type(operands, results)
```


Traits: SameOperandsAndResultElementType, TensorSizeTrait

Interfaces: NoMemoryEffect (MemoryEffectOpInterface)

Effects: MemoryEffects::Effect{}

#### Operands:

| Operand | Description |
| :-----: | ----------- |
| `src` | tensor of floating-point values or tensor of integer values or tensor of ptr values

#### Results:

| Result | Description |
| :----: | ----------- |
| `result` | tensor of floating-point values or tensor of integer values or tensor of ptr values

